{"meta":{"title":"IMSiuPong","subtitle":"PangJunJie","description":"iOS开发技术","author":"庞俊杰","url":"http://www.imsiupong.top"},"pages":[{"title":"tags","date":"2018-04-18T11:46:41.000Z","updated":"2018-04-18T11:46:41.138Z","comments":true,"path":"tags/index.html","permalink":"http://www.imsiupong.top/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-04-18T11:47:49.000Z","updated":"2018-04-18T11:47:49.610Z","comments":true,"path":"categories/index.html","permalink":"http://www.imsiupong.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Objective-C Runtime的属性和方法","slug":"MethodAndProperties","date":"2018-04-20T06:59:01.000Z","updated":"2018-04-20T07:42:17.294Z","comments":true,"path":"2018/04/20/MethodAndProperties/","link":"","permalink":"http://www.imsiupong.top/2018/04/20/MethodAndProperties/","excerpt":"","text":"简介在上篇文章Objective-C Runtime 类和对象中，我们了解了isa结构，知道了OC对象通过isa来查找存储在类中的方法等行为，但是class具体是怎么实现存储相关信息的，我们不得而知。这也是这篇文章的目的，解释OC类的具体结构 bits结构分析123456struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125; cache: 一个缓存，官方文档注释写明了用于缓存指针和虚表 下面我们来着重解释一下bits字段： bits用来存储类的属性，方法，协议等信息。它是一个class_data_bits_t类型 1234struct class_data_bits_t &#123; uintptr_t bits; // method here&#125; 这个结构体只有一个64bit的成员变量bits，先来看看这64bit分别存放的什么信息： class_bits_detail is_swift: 第一个bit，判断类是否是Swift类 has_default_rr：第二个bit，判断当前类或者父类含有默认的retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference 方法 require_raw_isa：第三个bit， 判断当前类的实例是否需要raw_isa (不是很懂) data：第4-48位，存放一个指向class_rw_t结构体的指针，该结构体包含了该类的属性，方法，协议等信息。至于为何只用44bit来存放地址，可以参考Objective-C Runtime 类和对象 class_rw_t和class_ro_t先来看看两个结构体的内部成员变量 123456789101112131415161718192021222324252627282930struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass;&#125;;struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; uint32_t reserved; const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties;&#125;; 可以看出,class_rw_t结构体内有一个指向class_ro_t结构体的指针。 每个类都对应有一个class_ro_t结构体和一个class_rw_t结构体。在编译期间,class_ro_t结构体就已经确定,objc_class中的bits的data部分存放着该结构体的地址。在runtime运行之后，具体说来是在运行runtime的realizeClass方法时，会生成class_rw_t结构体，该结构体包含了class_ro_t,并且更新data部分，换成class_rw_t结构体的地址。 用两张图来说明这个过程： 类的realizeClass运行之前： beforeRealizeClass 类的realizeClass运行之后： afterRealizeClass 细看两个结构体的成员变量会发现很多相同的地方，他们都存放着当前类的属性、实例变量、方法、协议等等。区别在于：class_ro_t存放的是编译期间就确定的；而class_rw_t是在runtime时才确定，它会先将class_ro_t的内容拷贝过去，然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说class_rw_t是class_ro_t的超集，当然实际访问类的方法、属性等也都是访问的class_rw_t中的内容","categories":[],"tags":[{"name":"iOS Develop Objective-C OC Runtime","slug":"iOS-Develop-Objective-C-OC-Runtime","permalink":"http://www.imsiupong.top/tags/iOS-Develop-Objective-C-OC-Runtime/"}]},{"title":"关于Tagged的一点讨论","slug":"关于Tagged的一点讨论","date":"2018-04-20T05:03:42.000Z","updated":"2018-04-20T06:25:38.474Z","comments":true,"path":"2018/04/20/关于Tagged的一点讨论/","link":"","permalink":"http://www.imsiupong.top/2018/04/20/关于Tagged的一点讨论/","excerpt":"","text":"开篇在之前讲述引用计数实现原理的文章中，我有提到过一种特别的存储方式，是使用TaggedPointer的一种特殊的指针来实现计数的，我们会在这彷文章中尽量解释清楚 本文主要参考的文档资料是: mikeash的Let’s Build Tagged Pointers 基本定义众所周知，指针是一个储存着内存地址的值，在很多的系统架构中存在着一种叫做内存对齐的思想： 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。 收尾工作:结构体的总大小,也就是sizeof的结果,必须是其内部最大成员的”最宽基本类型成员”的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。 sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址 内存对齐的主要作用： 平台原因：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常 性能原因：经过内存对齐后，CPU的内存访问速度大大提升","categories":[],"tags":[{"name":"iOS Devolp","slug":"iOS-Devolp","permalink":"http://www.imsiupong.top/tags/iOS-Devolp/"}]},{"title":"Runtime系列开篇","slug":"Runtime系列开篇","date":"2018-04-19T06:09:56.000Z","updated":"2018-04-19T06:20:12.213Z","comments":true,"path":"2018/04/19/Runtime系列开篇/","link":"","permalink":"http://www.imsiupong.top/2018/04/19/Runtime系列开篇/","excerpt":"","text":"前言将在工作学习中使用到的Runtime搜集并整理成如下几类: Class &amp;&amp; Object Property &amp;&amp; Method Category &amp;&amp; Association Object Message 上层API Runtime应用 其他 参考 苹果官方文档： Runtime Runtime的源码： 可编译源码 其他技术博客： Haven_ZN Draveness Vanney","categories":[],"tags":[{"name":"iOS Runtime Develop","slug":"iOS-Runtime-Develop","permalink":"http://www.imsiupong.top/tags/iOS-Runtime-Develop/"}]},{"title":"Objective-C引用计数原理分析","slug":"Objective-C引用计数原理分析","date":"2018-04-19T01:00:00.000Z","updated":"2018-04-20T06:27:40.167Z","comments":true,"path":"2018/04/19/Objective-C引用计数原理分析/","link":"","permalink":"http://www.imsiupong.top/2018/04/19/Objective-C引用计数原理分析/","excerpt":"","text":"Objective-C引用计数原理分析 本文使用的源码来自objc-4 723和CF-1153.18 本文前半部分着重介绍基本原理，后半部分可以尝试着结合实际问题分析 本文是在看到玉令天下的Objective-C 引用计数原理后决定自己尝试分析源码学习相关知识 本文也参考了太阳神的这篇黑幕背后的Autorelease文章 ##引用计数的存储方式 如果对象支持使用TaggedPointer, 那么苹果会直接将其指针值作为引用计数返回 如果当前设备是64位环境并且使用Objective-C 2.0，那么“一些”对象会使用其isa指针的一部分空间来存储它的引用计数 另外一种情况是Runtime会使用一张散列表来管理引用计数 是否使用垃圾回收（用UseGC属性判断），但这种早已弃用的东西就不要管了，而且初始化垃圾回收机制的void gc_init(BOOL wantsGC)方法一直被传入 NO。 TaggedPointer可以阅读TaggedPointer详解 判断对象是否使用TaggedPointer是看_OBJC_TAG_MASK的标志位是否是1UL： 1234567891011121314151617#if OBJC_MSB_TAGGED_POINTERS# define _OBJC_TAG_MASK (1UL&lt;&lt;63)#else# define _OBJC_TAG_MASK 1UL#endifstatic inline bool _objc_isTaggedPointer(const void * _Nullable ptr) &#123; return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;&#125;inline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) &#123; assert(!isTaggedPointer()); ...&#125; id其实就是objc_object *的简写（typedef struct objc_object *id;），它的isTaggedPointer()方法经常会在操作引用计数时用到，因为这决定了存储引用计数的策略。 isa指针基础知识：为什么使用nonpointer 用64 bit存储一个内存地址显然是种浪费，毕竟很少有那么大内存的设备。于是可以优化存储方案，用一部分额外空间存储其他内容。这里列出不同架构下的64位环境中isa指针结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; //对像所属的类在内存的位置或类的信息 uintptr_t bits;#if SUPPORT_PACKED_ISA // extra_rc must be the MSB-most field (so it matches carry/overflow flags) // nonpointer must be the LSB (fixme or get rid of it) // shiftcls must occupy the same bits that a real class pointer would // bits + RC_ONE is equivalent to extra_rc + 1 // RC_HALF is the high bit of extra_rc (i.e. half of its range) // future expansion: // uintptr_t fast_rr : 1; // no r/r overrides // uintptr_t lock : 2; // lock for atomic property, @synch // uintptr_t extraBytes : 1; // allocated with extra bytes // nonpointer# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL struct &#123; uintptr_t nonpointer : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 (uintptr_t)cls &gt;&gt; 3类的地址右移三位 因为类的地址的后三位没有实际作用 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) &#125;;# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL struct &#123; uintptr_t nonpointer : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8;# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7) &#125;;# else# error unknown architecture for packed isa# endif// SUPPORT_PACKED_ISA#endif#if SUPPORT_INDEXED_ISA# if __ARM_ARCH_7K__ &gt;= 2# define ISA_INDEX_IS_NPI 1# define ISA_INDEX_MASK 0x0001FFFC# define ISA_INDEX_SHIFT 2# define ISA_INDEX_BITS 15# define ISA_INDEX_COUNT (1 &lt;&lt; ISA_INDEX_BITS)# define ISA_INDEX_MAGIC_MASK 0x001E0001# define ISA_INDEX_MAGIC_VALUE 0x001C0001 struct &#123; uintptr_t nonpointer : 1; uintptr_t has_assoc : 1; uintptr_t indexcls : 15; uintptr_t magic : 4; uintptr_t has_cxx_dtor : 1; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 7;# define RC_ONE (1ULL&lt;&lt;25)# define RC_HALF (1ULL&lt;&lt;6) &#125;;# else# error unknown architecture for indexed isa# endif// SUPPORT_INDEXED_ISA#endif&#125;; SUPPORT_PACKED_ISA用于标记是否支持使用的isa指针包含更多的信息，其字面含义意思是isa的内容不再是类的指针了，而是包含了更多信息，比如引用计数，析构状态，被其他weak变量引用情况。判断方法也是根据设备类型，默认情况下使用64位的设备使用的都是nonpointer类型了 12345#if (!__LP64__ || TARGET_OS_WIN32 || TARGET_OS_SIMULATOR)# define SUPPORT_PACKED_ISA 0#else# define SUPPORT_PACKED_ISA 1#endif 变量名 含义 nonpointer 之前文章已经详细分析过了，可以参考上述文章 has_assoc 表示该对象是否包含 associated object，如果没有，则析构时会更快 has_cxx_dtor 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls 类的指针 magic 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。 weakly_referenced 表示该对象是否有过weak对象，如果没有，则析构时更快 deallocating 表示该对象是否正在析构 has_sidetable_rc 表示该对象的引用计数值是否过大无法存储在isa指针 extra_rc 存储引用计数值减一后的结果 在64位环境下，isa指针并不是就一定会存储引用计数，毕竟用 19bit （iOS 系统）保存引用计数不一定够。需要注意的是这 19 位保存的是引用计数的值减一。has_sidetable_rc 的值如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中，后面会详细讲。 散列表散列表来存储引用计数具体是用DenseMap类来实现，这个类中包含好多映射实例到其引用计数的键值对，并支持用DenseMapIterator迭代器快速查找遍历这些键值对。接着说键值对的格式：键的类型为DisguisedPtr&lt;objc_object&gt;，DisguisedPtr类是对objc_object *指针及其一些操作进行的封装，目的就是为了让它给人看起来不会有内存泄露的样子（真是心机裱），其内容可以理解为对象的内存地址；值的类型为__darwin_size_t，在darwin内核一般等同于unsigned long。其实这里保存的值也是等于引用计数减一。使用散列表保存引用计数的设计很好，即使出现故障导致对象的内存块损坏，只要引用计数表没有被破坏，依然可以顺藤摸瓜找到内存块的位置。 之前说引用计数表是个散列表，这里简要说下散列的方法。有个专门处理键的DenseMapInfo结构体，它针对DisguisedPtr做了些优化匹配键值速度的方法： 1234567891011121314struct DenseMapInfo&lt;DisguisedPtr&lt;T&gt;&gt; &#123; static inline DisguisedPtr&lt;T&gt; getEmptyKey() &#123; return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-1); &#125; static inline DisguisedPtr&lt;T&gt; getTombstoneKey() &#123; return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-2); &#125; static unsigned getHashValue(const T *PtrVal) &#123; return ptr_hash((uintptr_t)PtrVal); &#125; static bool isEqual(const DisguisedPtr&lt;T&gt; &amp;LHS, const DisguisedPtr&lt;T&gt; &amp;RHS) &#123; return LHS == RHS; &#125;&#125;; 当然这里的哈希算法会根据是否为64位平台来进行优化，算法具体细节就不深究了，我总觉得苹果在这里的hardcode是随便写的： 1234567891011121314151617#if __LP64__static inline uint32_t ptr_hash(uint64_t key)&#123; key ^= key &gt;&gt; 4; key *= 0x8a970be7488fda55; key ^= __builtin_bswap64(key); return (uint32_t)key;&#125;#elsestatic inline uint32_t ptr_hash(uint32_t key)&#123; key ^= key &gt;&gt; 4; key *= 0x5052acdb; key ^= __builtin_bswap32(key); return key;&#125;#endif 再介绍下SideTable这个类，它用于管理引用计数表和weak表，并使用spinlock_lock自旋锁来防止操作表结构时可能的竞态条件。它用一个64*128大小的uint8_t静态数组作为 buffer 来保存所有的SideTable实例。并提供三个公有属性： 123spinlock_t slock;//保证原子操作的自选锁RefcountMap refcnts;//保存引用计数的散列表weak_table_t weak_table;//保存 weak 引用的全局散列表 还提供了一个工厂方法，用于根据对象的地址在 buffer 中寻找对应的 SideTable 实例： 1static SideTable *tableForPointer(const void *p) weak表的作用是在对象执行dealloc的时候将所有指向该对象的weak指针的值设为nil，避免悬空指针。这是weak表的结构： 123456struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;&#125;; 苹果使用一个全局的weak表来保存所有的weak引用。并将对象作为键，weak_entry_t作为值。weak_entry_t中保存了所有指向该对象的weak指针。 ##引用计数的操作方式 ###获得引用计数 在非 ARC 环境可以使用retainCount方法获取某个对象的引用计数，其会调用objc_object的rootRetainCount()方法： 123- (NSUInteger)retainCount &#123; return ((id)self)-&gt;rootRetainCount();&#125; 在 ARC 时代除了使用Core Foundation库的CFGetRetainCount()方法，也可以使用Runtime的_objc_rootRetainCount(id obj)方法来获取引用计数，此时需要引入&lt;objc/runtime.h&gt;头文件。这个函数也是调用objc_object的rootRetainCount()方法： 1234567891011121314151617181920inline uintptr_t objc_object::rootRetainCount()&#123; if (isTaggedPointer()) return (uintptr_t)this; sidetable_lock(); isa_t bits = LoadExclusive(&amp;isa.bits); ClearExclusive(&amp;isa.bits); if (bits.nonpointer) &#123; uintptr_t rc = 1 + bits.extra_rc; if (bits.has_sidetable_rc) &#123; rc += sidetable_getExtraRC_nolock(); &#125; sidetable_unlock(); return rc; &#125; sidetable_unlock(); return sidetable_retainCount();&#125; rootRetainCount()方法对引用计数存储逻辑进行了判断，因为TaggedPointer前面已经说过了，可以直接获取引用计数；64位环境下的isa指针前面也说过了，所以这里的重头戏是在TaggedPointer无法使用时调用的sidetable_retainCount()方法： 12345678910111213141516uintptr_tobjc_object::sidetable_retainCount()&#123; SideTable *table = SideTable::tableForPointer(this); size_t refcnt_result = 1; spinlock_lock(&amp;table-&gt;slock); RefcountMap::iterator it = table-&gt;refcnts.find(this); if (it != table-&gt;refcnts.end()) &#123; // this is valid for SIDE_TABLE_RC_PINNED too refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; &#125; spinlock_unlock(&amp;table-&gt;slock); return refcnt_result;&#125; sidetable_retainCount()方法的逻辑就是先从SideTable的静态方法获取当前实例对应的SideTable对象，其refcnts属性就是之前说的存储引用计数的散列表，这里将其类型简写为RefcountMap： 1typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap; 然后在引用计数表中用迭代器查找当前实例对应的键值对，获取引用计数值，并在此基础上 +1 并将结果返回。这也就是为什么之前说引用计数表存储的值为实际引用计数减一。 需要注意的是为什么这里把键值对的值做了向右移位操作（it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT）: 1234567891011121314#ifdef __LP64__# define WORD_BITS 64#else# define WORD_BITS 32#endif// The order of these bits is important.#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)#define SIDE_TABLE_DEALLOCATING (1UL&lt;&lt;1) // MSB-ward of weak bit#define SIDE_TABLE_RC_ONE (1UL&lt;&lt;2) // MSB-ward of deallocating bit#define SIDE_TABLE_RC_PINNED (1UL&lt;&lt;(WORD_BITS-1))#define SIDE_TABLE_RC_SHIFT 2#define SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1)RefcountMap 可以看出值的第一个bit表示该对象是否有过weak对象，如果没有，在析构释放内存时可以更快；第二个bit表示该对象是否正在析构。从第三个bit开始才是存储引用计数数值的地方。所以这里要做向右移两位的操作，而对引用计数的+1和-1可以使用SIDE_TABLE_RC_ONE,还可以用SIDE_TABLE_RC_PINNED来判断是否引用计数值有可能溢出。 当然不能够完全信任这个_objc_rootRetainCount(id obj)函数，对于已释放的对象以及不正确的对象地址，有时也返回“1”。它所返回的引用计数只是某个给定时间点上的值，该方法并未考虑到系统稍后会把自动释放池清空，因而不会将后续的释放操作从返回值里减去。clang会尽可能把NSString实现成单例对象，其引用计数会很大。如果使用了TaggedPointer，`NSNumber的内容有可能就不再放到堆中，而是直接写在宽敞的64位栈指针值里。其看上去和真正的 NSNumber对象一样，只是使用TaggedPointer优化了下，但其引用计数可能不准确。 修改引用计数retain和release在非 ARC 环境下可以使用retain和release方法对引用计数进行加一减一操作，它们分别调用了 _objc_rootRetain(id obj)和 _objc_rootRelease(id obj)函数，不过后两者在ARC环境下也可使用。最后这两个函数又会调用objc_object的下面两个方法： 1234567891011121314151617inline id objc_object::rootRetain()&#123; assert(!UseGC); if (isTaggedPointer()) return (id)this; return sidetable_retain();&#125;inline bool objc_object::rootRelease()&#123; assert(!UseGC); if (isTaggedPointer()) return false; return sidetable_release(true);&#125; 这样的实现跟获取引用计数类似，先是看是否支持TaggedPointer毕竟数据存在栈指针而不是堆中，栈的管理本来就是自动的），否则去操作SideTable中的 refcnts属性，这与获取引用计数策略类似。sidetable_retain()将 引用计数加一后返回对象，sidetable_release()返回是否要执行dealloc方法： 12345678910111213141516171819202122232425262728293031bool objc_object::sidetable_release(bool performDealloc)&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.indexed);#endif SideTable *table = SideTable::tableForPointer(this); bool do_dealloc = false; if (spinlock_trylock(&amp;table-&gt;slock)) &#123; RefcountMap::iterator it = table-&gt;refcnts.find(this); if (it == table-&gt;refcnts.end()) &#123; do_dealloc = true; table-&gt;refcnts[this] = SIDE_TABLE_DEALLOCATING; &#125; else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123; // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&apos;t change it. do_dealloc = true; it-&gt;second |= SIDE_TABLE_DEALLOCATING; &#125; else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123; it-&gt;second -= SIDE_TABLE_RC_ONE; &#125; spinlock_unlock(&amp;table-&gt;slock); if (do_dealloc &amp;&amp; performDealloc) &#123; ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc); &#125; return do_dealloc; &#125; return sidetable_release_slow(table, performDealloc);&#125; 看到这里知道为什么在存储引用计数时总是真正的引用计数值减一了吧。因为release本来是要将引用计数减一，所以存储引用计数时先预留了个“一”，在减一之前先看看存储的引用计数值是否为 0（it-&gt;second &lt; SIDE_TABLE_DEALLOCATING），如果是，那就将对象标记为“正在析构”（it-&gt;second |= SIDE_TABLE_DEALLOCATING）,并发送dealloc消息，返回YES；否则就将引用计数减一（it-&gt;second -= SIDE_TABLE_RC_ONE）。这样做避免了负数的产生。 除此之外，Core Foundation库中也提供了增减引用计数的方法。比如在使用Toll-Free Bridge转换时使用的CFBridgingRetain和CFBridgingRelease 方法，其本质是使用 __bridge_retained和 __bridge_transfer告诉编译器此处需要如何修改引用计数： 1234567NS_INLINE CF_RETURNS_RETAINED CFTypeRef __nullable CFBridgingRetain(id __nullable X) &#123; return (__bridge_retained CFTypeRef)X;&#125;NS_INLINE id __nullable CFBridgingRelease(CFTypeRef CF_CONSUMED __nullable X) &#123; return (__bridge_transfer id)X;&#125; 此外Objective-C很多实现是靠Core Foundation Runtime来实现，Objective-C Runtime源码中有些地方明确注明：”// Replaced by CF“，那就是意思说这块任务被Core Foundation库接管了。当然Core Foundation有一部分是开源的。还有一些Objective-C Runtime函数的实现被诸如ObjectAlloc和NSZombie这样的内存管理工具所替代： 1234567891011121314// Replaced by ObjectAlloc+ (id)allocWithZone:(struct _NSZone *)zone &#123; return _objc_rootAllocWithZone(self, (malloc_zone_t *)zone);&#125;// Replaced by CF (throws an NSException)+ (id)init &#123; return (id)self;&#125;// Replaced by NSZombies- (void)dealloc &#123; _objc_rootDealloc(self);&#125; alloc new copy and mutablecopy根据编译器的约定，这以这四个单词开头的方法都会使引用计数加一。而new相当于调用alloc后再调用init： 1234567891011id_objc_rootAlloc(Class cls)&#123; return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);&#125;+ (id)alloc &#123; return _objc_rootAlloc(self);&#125;+ (id)new &#123; return [callAlloc(self, false/*checkNil*/) init];&#125; 可以看出alloc和new最终都会调用callAlloc，默认使用Objective-C 2.0且忽视垃圾回收和NSZone，那么后续的调用顺序依次是为 123class_createInstance()_class_createInstanceFromZone()calloc() calloc()函数相比于malloc()函数的优点是它将分配的内存区域初始化为0，相当于malloc()后再用memset()方法初始化一遍。 copy和mutableCopy都是基于NSCopying和NSMutableCopying方法约定，分别调用各类自己实现的copyWithZone:和mutableCopyWithZone:方法。这些方法无论实现方式是深拷贝还是浅拷贝，都会增加引用计数。（有些类的策略是懒拷贝，只增加引用计数但并不真的拷贝，等对象内容发生变化时再拷贝一份出来，比如 NSArray）。 在retain方法加符号断点会发现alloc, new, copy, mutableCopy这四个方法都会通过Core Foundation的CFBasicHashAddValue()函数来调用retain方法。其实CF有个修改和查看引用计数的入口函数__CFDoExternRefOperation，在CFRuntime.c文件中实现。","categories":[],"tags":[]},{"title":"Objective-C Runtime 类和对象的理解","slug":"ClassAndObjects","date":"2018-04-18T13:29:20.000Z","updated":"2018-04-20T06:55:29.062Z","comments":true,"path":"2018/04/18/ClassAndObjects/","link":"","permalink":"http://www.imsiupong.top/2018/04/18/ClassAndObjects/","excerpt":"","text":"#Objective-C 类和对象 ##类和对象的结构 继承于NSObject的类所生成的对象在runtime中都可以表示为这样的： 12345struct objc_object &#123;private: isa_t isa;&#125;;本文着重介绍类和对象 结构体中的其他参数会在后续的文章中介绍到 isa就是一个isa_t类型的结构体，从名字也可以看出来这个结构体指明了这个对象是什么，也就是所属的类，isa_t结构体的定义如下： 12345union isa_t &#123; Class cls; //对像所属的类在内存的位置或类的信息 uintptr_t bits;&#125;; 可以看到这个结构体中有个类型是Class的属性cls，里面应该存有关于这个对象的类的相关信息。 Class类的定义如下所示： 123456typedef struct objc_class *Class;struct objc_class : objc_object &#123; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125; Class就是结构体objc_class,而且objc_class继承于objc_object,所以也可以把Objective-C类看成是一个对象 如果类也是继承于objc_object，那么Class也有一个isa指针，那么isa指针指向什么位置呢？ 可以查看这些文章的内容: Class And MetaClass 大致内容是： 在Class之上还有一种元类(MetaClass)的存在，Class的isa指针指向的就是对应的MetaClass 在对象Objc中我们知道isa指向的类中描述对象的相关信息，那么相应的MetaClass中存放的就是描述类的相关信息，如方法、属性等，具体例子在文章下方 ClassAndMetaClass 上面这张图片很清楚的展示了：对象isa、类isa之间的关系 isa结构详细分析isa的结构体如下所示: 1234567891011121314151617181920212223242526union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;# __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL struct &#123; uintptr_t nonpointer : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8;# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7) &#125;;&#125; 具体参数的意义可以查看上篇文章：Objective-C引用计数的实现原理 nonpointer关键字可以阅读这篇文章：nonpointer) 大意就是在64位系统中，为了提高内存的利用率、提高性能，将isa中的一部分字段来存储其他信息 引伸一下： 123TaggedPointer和NonPointer的区别(自己理解)：1. TaggedPointer只使用1位来存储其他信息，isa则使用20位来存储其他信息，存储大小不同2. 存储位置不同，taggedpointer是在最低位存储 isa则不然 12345678910111213141516171819inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)&#123; initIsa(cls, true, hasCxxDtor);&#125;inline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) &#123; if (!nonpointer) &#123; isa.cls = cls; &#125; else &#123; isa_t newisa(0); newisa.bits = ISA_MAGIC_VALUE; newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3; isa = newisa; &#125;&#125; 上面的代码为isa的初始化过程，通过代码，我们可以清楚的知道isa是如何实现存储类信息的","categories":[],"tags":[{"name":"iOS Objective-C Object Class Develop","slug":"iOS-Objective-C-Object-Class-Develop","permalink":"http://www.imsiupong.top/tags/iOS-Objective-C-Object-Class-Develop/"}]},{"title":"LLDB的基本使用","slug":"LLDB的基本使用","date":"2018-04-18T13:29:20.000Z","updated":"2018-04-18T14:18:14.156Z","comments":true,"path":"2018/04/18/LLDB的基本使用/","link":"","permalink":"http://www.imsiupong.top/2018/04/18/LLDB的基本使用/","excerpt":"","text":"#引入在学习了与调试器共舞 - LLDB 的华尔兹后尝试着将学习到的知识练习一遍以加深印象 LLDB的基本介绍LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时暂停它，你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展。 基础使用help命令: 可以使用help &lt;command&gt;来了解有关命令的详细信息 print命令: 也可以使用prin、p或者pri来替换, print命令可以打印对象, 使用print -o(po), 也可以打印不同格式的变量rint/&lt;fmt&gt;或p/&lt;fmt&gt; 123print命令详解：当运行p count = 18表达式并输出count时，会发现结果和expression count = 18的结果是一样的，原因是因为当使用expression命令来修改某个变量的值时，expression可能需要参数，而print命令不必，expression为了标识和参数，会以--做为标识结束，以及输入的开始。例如： 果想要 -h 作为标识，就用 e -h -- +17，如果想计算它们的差值，就使用 e -- -h +17因为一般来说不使用标识的情况比较多，所以 e -- 就有了一个简写的方式，那就是 print。 expression命令: 可以使用e来替换, expression不仅可以改变调试器中的值，也可以改变程序中的值, 在调试器中还可以通过声明一个变量来减少输入量，不过为了能使用声明的变量, 变量必须以美元符号$开头 ##流程控制 一般情况下，当程序运行到断点位置时，在调试条上会出现四个可以用来控制程序执行流程的按钮： fourControlBtn 从左到右，四个按钮分别是：continue，step over，step into，step out continue 会取消程序的暂停，允许程序正常执行 (要么一直执行下去，要么到达下一个断点)。在LLDB中，你可以使用process continue命令来达到同样的效果，它的别名为continue，或者也可以缩写为c step over按钮，会以黑盒的方式执行一行代码。如果所在这行代码是一个函数调用，那么就不会跳进这个函数，而是会执行这个函数，然后继续。LLDB则可以使用thread step-over，next，或者n命令。 step in 跳进一个函数调用来调试或者检查程序的执行情况, 或者在LLDB中使用thread step in，step，或者s命令。注意，如果当前行不是函数调用时，next和step效果是一样的。 step out 会执行到下一个返回语句 (直到一个堆栈帧结束) 然后停止 调试时，还有一个很棒的函数可以用来控制程序流程：thread return。它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后立刻执行返回命令，跳出当前栈帧。这意味这函数剩余的部分不会被执行。这会给ARC的引用计数造成一些问题，或者会使函数内的清理部分失效。但是在函数的开头执行这个命令，是个非常好的隔离这个函数，伪造返回值的方式 。 ##断点 在 Xcode 的左侧面板，有一组按钮。其中一个看起来像断点。点击它打开断点导航，这是一个可以快速管理所有断点的面板。 breakPointManager 在这里你可以看到所有的断点 - 在LLDB中通过breakpoint lis(或者br li) 命令也做同样的事儿。你也可以点击单个断点来开启或关闭 - 在LLDB中使用breakpoint enable &lt;breakpointID&gt;和breakpoint disable &lt;breakpointID&gt; ###创建断点 在上面的例子中，我们通过在源码页面器的滚槽16上点击来创建断点。你可以通过把断点拖拽出滚槽，然后释放鼠标来删除断点 (消失时会有一个非常可爱的噗的一下的动画)。你也可以在断点导航页选择断点，然后按下删除键删除。 要在调试器中创建断点，可以使用breakpoint set命令。 12(lldb) breakpoint set -f main.m -l 16Breakpoint 1: where = DebuggerDance`main + 27 at main.m:16, address = 0x000000010a3f6cab 也可以使用缩写形式br。虽然b是一个完全不同的命令 (_regexp-break 的缩写)，但恰好也可以实现和上面同样的效果。 12(lldb) b main.m:17Breakpoint 2: where = DebuggerDance`main + 52 at main.m:17, address = 0x000000010a3f6cc4 也可以在一个符号 (C 语言函数) 上创建断点，而完全不用指定哪一行 1234(lldb) b isEvenBreakpoint 3: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x000000010a3f6d00(lldb) br s -F isEvenBreakpoint 4: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x000000010a3f6d00 这些断点会准确的停止在函数的开始。Objective-C 的方法也完全可以： 12345678(lldb) breakpoint set -F &quot;-[NSArray objectAtIndex:]&quot;Breakpoint 5: where = CoreFoundation`-[NSArray objectAtIndex:], address = 0x000000010ac7a950(lldb) b -[NSArray objectAtIndex:]Breakpoint 6: where = CoreFoundation`-[NSArray objectAtIndex:], address = 0x000000010ac7a950(lldb) breakpoint set -F &quot;+[NSSet setWithObject:]&quot;Breakpoint 7: where = CoreFoundation`+[NSSet setWithObject:], address = 0x000000010abd3820(lldb) b +[NSSet setWithObject:]Breakpoint 8: where = CoreFoundation`+[NSSet setWithObject:], address = 0x000000010abd3820 如果想在 Xcode 的UI上创建符号断点，你可以点击断点栏左侧的 + 按钮。 addBreakPoint 然后选择第三个选项： adBreakPoint 这时会出现一个弹出框，你可以在里面添加例如-[NSArray objectAtIndex:]这样的符号断点。这样每次调用这个函数的时候，程序都会停止，不管是你调用还是苹果调用。 如果你 Xcode 的 UI 上右击任意断点，然后选择 “Edit Breakpoint” 的话，会有一些非常诱人的选择。 addBreakPoint ###断点行为 上面的例子中，你或许想知道每一次到达断点的时候 i 的值。我们可以使p i作为断点行为。这样每次到达断点的时候，都会自动运行这个命令。 breakPointAction 你也可以添加多个行为，可以是调试器命令，shell 命令，也可以是更直接的打印： breaPointAction 看编辑断点弹出窗口的底部，你还会看到一个选项： “Automatically continue after evaluation actions.” 。它仅仅是一个选择框，但是却很强大。选中它，调试器会运行你所有的命令，然后继续运行。看起来就像没有执行任何断点一样 (除非断点太多，运行需要一段时间，拖慢了你的程序)。 这个选项框的效果和让最后断点的最后一个行为是 continue 一样。选框只是让这个操作变得更简单。 执行断点后自动继续运行，允许你完全通过断点来修改程序！你可以在某一行停止，运行一个 expression 命令来改变变量，然后继续运行。","categories":[],"tags":[]},{"title":"Start","slug":"Start","date":"2018-04-18T13:24:55.000Z","updated":"2018-04-18T13:26:26.100Z","comments":true,"path":"2018/04/18/Start/","link":"","permalink":"http://www.imsiupong.top/2018/04/18/Start/","excerpt":"","text":"做为博客搭建后的第一条, 系统的阐述一下搭建时的想法还是很有必要的： 为了记录我在开发和学习过程中学习到的新的技术知识等 阐述自己的有关技术部分想法并将之实践的过程 记录自己的其他状态等 前几条博文主要以基础知识、调试技能介绍为主。后期则开始在我最大能力的前提下，尽量系统、详细的描述相关知识技能等。","categories":[],"tags":[]}]}